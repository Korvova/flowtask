# Таблица требований - Flowtask

## Основная информация
- **Название таблицы Entity Storage:** `tflow_nodes`
- **Проект:** Flowtask - визуальное управление задачами в Bitrix24
- **Архитектура:** Single Table Design (одна таблица для всех данных)

---

## Требования

| № | Описание | Особенности | Статус |
|---|----------|-------------|--------|
| 1 | При открытии задачи создается запись в таблице `tflow_nodes` | **NAME:** `process_{taskId}_node_task-{taskId}`<br>**DETAIL_TEXT:** JSON с данными узла<br>**Пример:** process_154_node_task-154 | ✅ Реализовано |
| 2 | Создание предзадачи сохраняет `processId` родителя | **Поле в JSON:** `processId: 154`<br>**NAME:** `process_{processId}_node_future-{timestamp}`<br>**Пример:** process_154_node_future-1761831843661 | ✅ Реализовано |
| 3 | При завершении задачи предзадача становится реальной задачей | **Логика:** TaskCreator использует `futureData.processId`<br>**Наследование:** Новая задача получает processId из предзадачи<br>**Пример:** future-123 → task-155 с processId=154 | ✅ Реализовано |
| 4 | Открытие связанной задачи показывает общий процесс | **Логика:** TaskProcessMapping ищет запись по `task-{taskId}`<br>**Извлечение:** Из NAME получает processId через regex<br>**Загрузка:** EntityManagerV2.loadProcess(processId) | ✅ Реализовано |
| 5 | FILTER по NAME для быстрой загрузки | **Синтаксис:** `FILTER: { '%NAME': 'process_154' }`<br>**Эффект:** Загружает только записи конкретного процесса<br>**Производительность:** 3-5 записей вместо 3000+ | ✅ Реализовано |
| 6 | Ранняя остановка при загрузке списка процессов | **Логика:** Останавливается после 3 батчей без новых процессов<br>**Группировка:** Во время загрузки, не после<br>**Оптимизация:** ~200 записей вместо 500 | ✅ Реализовано |

---

## Структура записи в `tflow_nodes`

### Формат NAME
```
process_{processId}_node_{nodeType}-{nodeId}
```

**Примеры:**
- `process_154_node_task-154` - реальная задача
- `process_154_node_future-1761831843661` - предзадача
- `process_154_node_task-155` - задача созданная из предзадачи

### Формат DETAIL_TEXT (JSON)
```json
{
  "nodeId": "task-154",
  "type": "task",
  "title": "Название задачи",
  "description": "Описание",
  "responsibleId": 1,
  "groupId": 0,
  "status": 2,
  "positionX": 400,
  "positionY": 300,
  "realTaskId": 154,
  "processId": 154
}
```

---

## Логика работы

### 1. Создание первой задачи
```
Задача 154 → process_154_node_task-154 (processId = 154)
```

### 2. Создание предзадачи
```
Предзадача от 154 → process_154_node_future-123 (processId: 154 сохранен в JSON)
```

### 3. Завершение задачи
```
TaskCreator читает: futureData.processId = 154
Создает задачу 155: process_154_node_task-155 (наследует processId!)
```

### 4. Открытие задачи 155
```
TaskProcessMapping ищет: FILTER { '%NAME': 'task-155' }
Находит: process_154_node_task-155
Извлекает: processId = 154
Загружает: весь process_154 (обе задачи 154 и 155)
```

---

## Преимущества Single Table Design

1. **Одна таблица** вместо множества (tflow_nodes, tflow_future, tflow_conn, tflow_pos)
2. **FILTER на уровне API** - не нужно загружать все и фильтровать в JS
3. **Простой маппинг** через NAME без JOIN'ов
4. **Быстрый поиск** процесса по taskId через regex

---

## Известные проблемы и решения

| Проблема | Решение | Статус |
|----------|---------|--------|
| Бесконечная загрузка процессов | Добавлен FILTER в getAllProcesses | ✅ Исправлено |
| Задачи не делят общий canvas | TaskProcessMapping извлекает processId из NAME | ✅ Исправлено |
| Захламление базы при удалении задач | Функция cleanupDeletedProcesses проверяет существование задач | ✅ Реализовано |
| Загрузка 6000+ записей при очистке | Добавлен FILTER: '%NAME': 'process_' в nukeStorage | ✅ Исправлено |

---

## Следующие требования (TODO)

| № | Описание | Приоритет |
|---|----------|-----------|
| 7 | Автоматическое удаление процессов при удалении задач | Средний |
| 8 | Экспорт/импорт процессов | Низкий |
| 9 | Шаблоны процессов | Низкий |
| 10 | История изменений процесса | Низкий |

---

**Последнее обновление:** 2025-01-30
